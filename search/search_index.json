{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Bash Task Master is a utility to organize and write specialized bash scripts AKA tasks.</p> <p>Features:</p> <ul> <li> <p>Scoped Context</p> <ul> <li>Project specific tasks are stored and loaded based on the current working directory</li> <li>Modules tasks are available anywhere</li> </ul> </li> <li> <p>Parse and Validate Input</p> <ul> <li>Reference arguments by name (<code>$ARG_VAR</code>)</li> <li>Ensure that arguments match an expected format</li> </ul> </li> <li> <p>Isolated Runtime</p> <ul> <li>Task variables and functions do not pollute the user session</li> </ul> </li> <li> <p>Centralized Management</p> <ul> <li>Manage modules, drivers and templates from anywhere</li> </ul> </li> </ul> <p>Bash Task Master was designed to be flexible and expandable.</p> <p>Task files act as documentation for important processes. While a simple bash script would serve the same purpose, the aim is to make it easier to co-locate project resources. There are also quality of life aspects like argument parsing and state storage.</p> <p>For example, let's say we wanted to lint, test, and run every project that we worked on. Without bash task master, we would need to remember the command and arguments for each tool that performs each individual command. With bash task master, it's as easy as running <code>task lint</code>, <code>task test</code>, and <code>task run</code> in a project directory.</p>"},{"location":"#installation","title":"Installation","text":"<p>You do not need elevated permissions to install. It is preferred to run bash-task-master as a non-sudo user.</p> <p>1. Install the latest version: <pre><code>curl -L https://hppr.dev/install-btm.sh | bash\n</code></pre></p> <p>2. Log out</p> <p>3. Log back in</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>1. Create a new directory</p> <pre><code>mkdir tutorial\ncd tutorial\n</code></pre> <p>2. Initialize a task file</p> <pre><code>task init\n</code></pre> <p>3. Write a task</p> <pre><code>task edit # opens tasks.sh in vi by default\n</code></pre> <p>Add the following to the file and exit.</p> <pre><code>arguments_greet() {\nGREET_DESCRIPTION=\"An example task!\"\nGREET_REQUIREMENTS=\"name:n:str\"\n}\n\ntask_greet() {\necho \"Hello $ARG_NAME, good day to you!\"\n}\n</code></pre> <p>4. Run it!</p> <pre><code>task greet -n \"internet\" # Run the task\nRunning greet: task...\nHello internet, good day to you!\n</code></pre> <p>5. Show help!</p> <pre><code>task help greet          # Get help on the task\nRunning help:greet task...\n  Command: task greet\n    An example task!\n    Required:\n      --name, -n str\n</code></pre> <p>6. Validate arguments!</p> <pre><code>task greet               # Fail the task\nMissing required argument: --name\n</code></pre>"},{"location":"#calling-tasks","title":"Calling Tasks","text":"<p>Tasks are called using the <code>task</code> command (or the <code>t</code> alias). The <code>task</code> command takes any number of arguments. The first argument is always interpreted as the command you would like to run. Everything after the command depends on what type of task file you are using.</p> <p>The default way that commands are parsed is with the bash task syntax. This syntax interprets the first argument not starting with <code>-</code> after the command as an optional subcommand. Everything after the subcommand is required to be an argument.</p> <p>Example</p> <p></p>"},{"location":"built_in_tasks/","title":"Builtin Tasks","text":"<p>The following is a summary of all built in tasks that are shipped with bash task master.</p> <p>In the examples all arguments are given in their long form, but short arguments are also accepted. The short form arguments are standardized as the first letter of the long form. For example, the short form of <code>--dir</code> would be <code>-d</code>.</p> <p>This information can also be easily accessed by running <code>task help COMMAND_NAME</code>.</p>"},{"location":"built_in_tasks/#init","title":"Init","text":"<p>Initialize a local task file.</p> <pre><code># Create a .tasks.sh file in the current directory\n# Uses the default bash template\n# Adds a bookmark with the directory name\ntask init\n\n# Create a tasks.sh file in target directory and names it project\ntask init --dir target --name project\n\n# Create a .tasks.sh file from a given template\ntask init --template custom\n\n# Create default task file for mydriver\n# If a template does not exist, create an empty task file that uses the naming convention of mydriver\n# NOTE: -D is the short argument for --driver\ntask init --driver mydriver\n</code></pre>"},{"location":"built_in_tasks/#list","title":"List","text":"<p>List available tasks.</p> <pre><code># List all tasks available\ntask list\n\n# List all global tasks\ntask list --global\n\n# List all local tasks\ntask list --local\n</code></pre>"},{"location":"built_in_tasks/#edit","title":"Edit","text":"<p>Edit the current local task file. Opens the editor specified in the <code>DEFAULT_EDITOR</code> variable in <code>$TASK_MASTER_HOME/config.env</code>. After exiting the editor bash-task-master will check that the tasks.sh file is valid bash. If the file is not valid it will give you the option to either open it back up or revert the changes.</p> <pre><code># Edit the current tasks file with the DEFAULT_EDITOR\ntask edit\n</code></pre>"},{"location":"built_in_tasks/#bookmark","title":"Bookmark","text":"<p>Bookmark directories.</p> <pre><code># Bookmark the current directory\n# Uses the current directory as it's name\ntask bookmark\n\n# Bookmark the current directory as loc\ntask bookmark --name loc\n\n# Create a bookmark to some/other/dir named mydir\ntask bookmark --dir some/other/dir --name mydir\n\n# List bookmarks\ntask bookmark list\n\n# Remove a bookmark\ntask bookmark rm --name mybookmark\n</code></pre>"},{"location":"built_in_tasks/#goto","title":"Goto","text":"<p>Change directories to previously bookmarked directories.</p> <pre><code># Goto the bookmarked proj directory\ntask goto proj\n</code></pre>"},{"location":"built_in_tasks/#help","title":"Help","text":"<p>Show Help.</p> <pre><code># Show help for mycommand\ntask help mycommand\n</code></pre>"},{"location":"built_in_tasks/#template","title":"Template","text":"<p>Manage task file templates</p> <pre><code># Edit the default bash template\ntask template edit --name bash\n\n# Edit/create a new custom template\ntask template edit --name custom\n\n# Remove the custom template\ntask template rm --name custom\n\n# List templates\ntask template list\n</code></pre>"},{"location":"built_in_tasks/#module","title":"Module","text":"<p>Manage modules.</p> <pre><code># Enable mymodule\n# Searches TASK_REPOS from $TASK_MASTER_HOME/config.env for the module if it not found locally.\ntask module enable --name mymodule\n\n# Disable mymodule\ntask module disable --name mymodule\n\n# List all enabled or disabled modules\ntask module list --all\n\n# List all remotely available modules\ntask module list --remote\n\n# List all enabled modules\ntask module list --enabled\n\n# List all diabled modules\ntask module list --disabled\n\n# Remove all disabled modules\ntask module clean\n</code></pre>"},{"location":"built_in_tasks/#driver","title":"Driver","text":"<p>Manage task drivers</p> <pre><code># Enable mydriver\n# Searches TASK_REPOS from $TASK_MASTER_HOME/config.env for the driver if it is not found locally\ntask driver enable --name mydriver\n\n# Disable mydriver\ntask driver disable --name mydriver\n\n# List installed drivers\ntask driver list\n\n# List drivers available remotely\ntask driver list --remote\n</code></pre>"},{"location":"built_in_tasks/#state","title":"State","text":"<p>Interact with stored state information</p> <pre><code># Show all current variables\ntask state show\n\n# Set a variable for the current context.\ntask state set --key myvar --value 10\n\n# Remove a variable for the current context.\ntask state unset --key myvar\n\n# Edit the variables for a command.\n# Uses the `DEFAULT_EDITOR` setting in $TASK_MASTER_HOME/config.env as the editor.\ntask state edit\n\n# Remove all empty state files and bookmarks that refer to missing directories.\ntask state clean\n</code></pre>"},{"location":"built_in_tasks/#global","title":"Global","text":"<p>Global Utilities.</p> <pre><code># Update to the most recent release\ntask global update\n\n# Update to the dev version (irreversible)\ntask global update --dev\n\n# Update to version 1.0\ntask global update --version 1.0\n\n# Show version information\ntask global version\n</code></pre>"},{"location":"drivers/","title":"Drivers","text":"<p>Drivers are resposible for executing, listing and providing help for tasks. The driver defines the format and filename for a task file. By default, the only driver included in Bash Task Master is the bash driver. Built-in tasks and modules use the bash driver.</p> <p>See below on how to implement a driver to support different file formats.</p> <p>Drivers are managed by the built-in driver module.</p> <p>Note</p> <p>Disabling a driver is non destructive. Driver files remain in place but the filename association is temporarily removed. This is so that if you want to re-enable a driver, it does not redownload the assets.</p>"},{"location":"drivers/#bash-driver","title":"Bash Driver","text":"<p>The bash driver is used whenever a task file is named tasks.sh or .tasks.sh. As the name implies, it is implemented in bash and the task file is a bash script. Arguments and tasks are defined in bash functions which are loaded by the main task function.</p>"},{"location":"drivers/#tasks","title":"Tasks","text":"<p>Tasks in a bash task file are created as functions with the <code>task_</code> prefix in the tasks.sh file. Anything after <code>task_</code> is treated as the task name:</p> <pre><code># Example tasks.sh file\n\n# run with task clean\ntask_clean() {\n...\n}\n\n# run with task check_all\ntask_check_all() {\n...\n}\n</code></pre>"},{"location":"drivers/#arguments","title":"Arguments","text":"<p>Each argument given to a task is loaded into the task as an <code>ARG_</code> variable. By default, any long argument, i.e. one that starts with a <code>--</code>, is loaded with the same name as it was given on the command line. For example, running <code>task hello --foo bar</code> would run the <code>task_hello</code> function with <code>ARG_FOO=bar</code>.</p>"},{"location":"drivers/#specifying-arguments","title":"Specifying Arguments","text":"<p>Arguments can be defined in an <code>arguments_TASKNAME</code> function. This function should be loaded alongside the task definition, i.e. inside the same tasks.sh file. The variables inside this function are used to parse and validate the arguments before the task function is run.</p> <p>The following variables are supported in arguments functions:</p> Variable Name Description Example <code>SUBCOMMANDS</code> a <code>|</code> delimited list of subcommands. <code>SUBCOMMANDS=\"sign|clean|init\"</code> <code>[COMMAND]_DESCRIPTION</code> help string for a COMMAND or SUBCOMMAND <code>BUILD_DESCRIPTION=\"Build the project\"</code> <code>[COMMAND]_REQUIREMENTS</code> required arguments for a COMMAND or SUBCOMMAND. <code>INIT_REQUIREMENTS=\"out:o:str dir:d:str\"</code> <code>[COMMAND]_OPTIONS</code> arguments for a COMMAND or SUBCOMMAND <code>CLEAN_OPTIONS=\"f:force:bool\"</code> <p>Note that DESCRIPTION, REQUIREMENTS and OPTIONS can be used with a command AND/OR a subcommand.</p> <p>REQUIREMENTS and OPTIONS are written as lists of space delimited argument specifications that are of the form: long-arg:short-arg:arg-type.</p> <p>The long-arg of the argument specifies the flag to be used with <code>--</code> and also denotes the portion of the <code>ARG_</code> variable in the tasks. The short-arg is the flag to be used with <code>-</code> (single dash). The arg-type specifies what type the argument is. See below for available types.</p> <p>Example</p> <p></p> <p>The above specification specifies that the compose command has 3 optional arguments: <code>--name</code> or <code>-n</code>, <code>--host</code> or <code>-h</code>, <code>--iterations</code> or <code>-i</code>. In the task we could access these values as <code>ARG_NAME</code>, <code>ARG_HOST</code> and <code>ARG_ITERATIONS</code> respectively.</p> <p>Note</p> <p>All dashes (<code>-</code>) in subcommands and arguments are converted to underscores (<code>_</code>). i.e. <code>task thing --my-way 100</code> would have <code>ARG_MY_WAY=100</code>.  </p>"},{"location":"drivers/#arguments-example","title":"Arguments Example","text":"<p>If the following arguments are defined for the build task:</p> <pre><code>arguments_build() {\nSUBCOMMANDS=\"help|frontend|backend|all\"\nFRONTEND_REQUIREMENTS=\"out:o:str in:i:str\"\nFRONTEND_OPTIONS=\"verbose:v:bool lint:L:bool dir:d:str\"\nBACKEND_REQUIREMENTS=\"pid:P:int\"\nBACKEND_OPTIONS=\"verbose:v:bool build-first:B:bool\"\n}\n</code></pre> <p>Then all of the following calls would succeed:</p> <pre><code>task build frontend --out outdir --in infile\ntask build frontend --out outdir --in infile --lint --verbose\ntask build frontend -o outdir -i infile -L -v\ntask build all\ntask build backend --pid 123\ntask build backend -P 123\ntask build backend -vBP 123\ntask build frontend -Lo outdir -vi infile\n</code></pre> <p>But none of the following:</p> <pre><code>task build frontend                              # Missing required arguments\ntask build frontend --in infile --lint --verbose # Unknown argument --in\ntask build backend -P 12 -v garbage              # Verbose is not a bool\n</code></pre>"},{"location":"drivers/#supported-argument-types","title":"Supported Argument Types","text":"<p>Available types are as follows:</p> Type Identifier Description String str A string of characters, can pretty much be anything. Integer int An integer Boolean bool An argument that is either T if present or an empty string if not* Word nowhite A string with no whitespaces Uppercase upper An uppercase string Lowercase lower A lowercase string Single Char single A single character* <p>All types, except for bool, require that a value is given. With bool arguments, the argument being present automatically sets the <code>ARG_VAR</code>. Note that short arguments can be combined to one combined argument, e.g -vBP, but only the last can be a non bool.</p> <p>Note</p> <p>A single character may be confused as a boolean at validation time. If a value for a single character argument is left out, it will be set to \"1\"</p>"},{"location":"drivers/#custom-drivers","title":"Custom Drivers","text":"<p>Task drivers are determined by the filename of the task file. The tasks.sh and .task.sh filenames are associated with the bash_driver. A custom driver needs to have a unique name for it's task file.</p> <p>The way that the task runner switches between drivers is by loading different sets of functions for executing, listing and providing help on tasks.</p> <p>The following variables indicate what command or function to run when processing a task file.</p> Variable Name Arguments Description DRIVER_EXECUTE_TASK $@ Executes a task. Gets passed all of the arguments to the task function. DRIVER_HELP_TASK TASK_COMMAND Shows the help for the given command. DRIVER_LIST_TASKS TASKS_FILE Lists the available tasks in the given task file. Outputs a space or newline separated list of tasks. The list is used to verify that the task is defined. DRIVER_VALIDATE_TASK_FILE TASKS_FILE Validates a that the given task file is readable by the driver. <p>Different languages may be used to implement custom drivers but the driver must define these variables to interface with the execution environment.</p> <p>The following driver file would define an alternative bash driver that doesn't do anything with arguments and just executes hello, world, foo and bar tasks:</p> <pre><code>DRIVER_EXECUTE_TASK=execute_task\nDRIVER_HELP_TASK=not_helpful\nDRIVER_LIST_TASKS=acceptable_tasks\nDRIVER_VALIDATE_TASK_FILE=noop\n\nnoop() {\nreturn 0\n}\n\nexecute_task() {\ntask_$1\n}\n\nnot_helpful() {\necho rtfd\n}\n\nacceptable_tasks() {\necho \"hello world foo bar\"\n}\n</code></pre>"},{"location":"drivers/#installing-a-custom-driver","title":"Installing a Custom Driver","text":"<p>Note</p> <p>This step only applies to drivers outside of repositories. It is handled automatically when running <code>task driver enable</code>, See repositories for more information.</p> <p>After the source for a driver is added to the <code>$TASK_MASTER_HOME/lib/drivers/</code> directory, the <code>$TASK_MASTER_HOME/lib/drivers/installed_drivers.sh</code> file must be updated with the filename that should be associated with the driver.</p> <p>For example, to install the pydriver driver to process task files named .tasks.py, add the following to the <code>installed_drivers.sh</code> file:</p> <pre><code>TASK_FILE_NAME_DICT[.tasks.py]=pydriver\nTASK_DRIVER_DICT[pydriver]=pydriver.sh\n</code></pre> <p>where <code>my_driver.sh</code> is the filename of the driver in the <code>$TASK_MASTER_HOME/lib/drivers/</code> directory.</p>"},{"location":"modules/","title":"Modules","text":"<p>Modules are task files that are available globally throughout your user environment. These modules are kept in the <code>$TASK_MASTER_HOME/modules</code> directory. Module files use the bash task syntax. Modules define tasks and/or functions that may be used in tasks anywhere in a users environment.</p>"},{"location":"modules/#managing-modules","title":"Managing modules","text":"<p>Modules can be managed using the built in module task. This task is responsible for downloading, enabling, disabling and listing local and remote modules.</p>"},{"location":"modules/#local-modules","title":"Local Modules","text":"<p>Modules may be created locally by placing a file ending in <code>-module.sh</code> directly in <code>$TASK_MASTER_HOME/modules</code>. Any file that ends in <code>-module.sh</code> will be loaded when running the task.</p> <p>Note</p> <p>When writing modules it is important to be aware of possible collisions with other modules that are loaded. It is a good idea to mark all module functions as read only by running <code>readonly -f task_mymod</code> at the end of the module. This will notify module users if any function has been redeclared.</p>"},{"location":"modules/#repository-modules","title":"Repository Modules","text":"<p>Modules may also be hosted remotely to share modules between users and installations.</p> <p>Add another repo by updating <code>TASK_REPO</code> in the <code>$TASK_MASTER_HOME/config.sh</code> file with the uri of the repositories inventory file:</p> <pre><code>TASK_REPOS=\"https://raw.githubusercontent.com/hppr-dev/btm-extra/main/inventory https://myrepo/inventry\"\n</code></pre> <p>After adding the repository, any module hosted on the added repository is enablable by running <code>task module enable -n MOD_NAME</code>.</p> <p>Warning</p> <p>It is important to vet and review any module repositories that you would like to use. If you are wary of a module source, make sure to be logged in as an unpriviledged user (i.e. without passwordless sudo). Any module task is run with the same permissions as the logged in user.</p>"},{"location":"repositories/","title":"Repositories","text":"<p>Repositories store modules and drivers for sharing and reuse. Update the <code>TASK_REPOS</code> config value in <code>$TASK_MASTER_HOME/config.env</code> to add a module repository. By default, <code>TASK_REPOS</code> is set to use the official extras repository on github: btm-extra. The <code>TASK_REPOS</code> value should be a space separated list of URIs of repository inventory files.</p>"},{"location":"repositories/#inventory-file","title":"Inventory File","text":"<p>Each task repository needs to have an <code>inventory</code> file that enumerates what drivers and modules it provides. The inventory file lists the available modules and which files correspond with what modules and drivers.</p> <p>The inventory file format is a simple key, value format. Any line that is not in the format of key=value is ignored.</p> <p>The <code>MODULE_DIR</code> and <code>DRIVER_DIR</code> are special required keys that are used to specify the directory relative to the inventory file that contains the driver and module files. Keys that start with <code>module-</code> point to module files and <code>driver-</code> keys point to driver files.</p> <p>Example</p> <p>The following repository contains the venv, gonv, and todo modules and the gitlab driver: <pre><code>  ===== Directories =====\n\n  MODULE_DIR = modules\n  DRIVER_DIR = drivers\n\n  ===== Included Modules =====\n\n  module-venv = venv-module.sh.disabled\n  module-gonv = gonv-module.sh.disabled\n  module-todo = todo-module.sh.disabled\n\n  ====== Included Drivers =====\n\n  driver-gitlab = gitlab-driver.sh\n</code></pre></p>"},{"location":"repositories/#repository-modules","title":"Repository Modules","text":"<p>Repository modules are required to be contained in a single file. This file should be referenced by the <code>module-NAME</code> line in the inventory line. Modules should always define an arguments functions that defines a description so that users have a quick reference for the provided task's usage.</p>"},{"location":"repositories/#repository-drivers","title":"Repository Drivers","text":"<p>Repository drivers must implement all of the keys of the driver interface. If a driver does not implement all of the proper variables, the task function will fail when trying to use it.</p> <p>Driver settings are enumerated in the driver file in the repository. These are specified by using key value comments in the driver's bash file. Here is a list of directives that are supported:</p> Directive Required? Description task_file_name YES The task file name to use with this driver. Automatically installed into the installed_drivers.sh file. extra_file An extra file to download into the DRIVER_DIR along with the driver. May have any number of files specified. These file paths are relative to the where the driver.sh file is stored. dependency Denotes a dependency needed to run the driver. If the given command is not found, the driver installation will fail setup A setup script to run after pulling down files, but before enabling the driver. If this script fails, driver installation will fail. <p>Example</p> <p>Here is an example of a driver with all of the directives being used:</p> <pre><code># Used for tasks.yaml files\n# tasks_file_name = tasks.yaml\n\n# Needs two extra files\n# extra_file = yaml/validator.py\n# extra_file = yaml/executor.py\n\n# Requires python to be installed\n# dependency = python\n\n# Setup script to run after downloading the extra files\n# setup = yaml/setup.sh\n\n...\n</code></pre> <p>And the repository would have the following structure:</p> <pre><code>inventory\ndrivers/\n    yaml_driver.sh\n    yaml/\n        validator.py\n        executor.py\n        setup.sh\n</code></pre>"},{"location":"repositories/#repository-hosting","title":"Repository Hosting","text":"<p>Inventory files are pulled using <code>curl</code>. The btm-extra file is hosted on github, but any curl-able url will work. The only requirement is that the requesting host can connect and access the inventory file and the MODULE_DIR and DRIVER_DIR directories.</p> <p>To pull from the local filesystem you can add a url like <code>file:///home/me/myrepo/inventory</code> to <code>TASK_REPOS</code></p>"},{"location":"state/","title":"State","text":""},{"location":"state/#local-context-state","title":"Local Context State","text":"<p>Each task file context has a file in <code>$TASK_MASTER_HOME/state/$TASK_NAME.vars</code> to save state variables.</p> <p>The <code>persist_var</code> function is used to save a state value:</p> <pre><code>persist_var \"INITIALIZED\" \"true\"\n</code></pre> <p>After calling <code>persist_var</code> on a variable, it will be set for any current or future task within the current task file context.</p> <p>The <code>remove_var</code> function does the opposite of <code>persist_var</code>. It removes values from the stored state:</p> <pre><code>remove_var \"INITIALIZED\"\n</code></pre> <p>The <code>export_var</code> function is used to export a value to the calling user's shell:</p> <pre><code>export_var \"SOME_VAR\" \"44\"\n</code></pre> <p>The <code>hold_var</code> and <code>release_var</code> functions save the current value of a variable in state:</p> <pre><code># Save the current value for PS1\nhold_var \"PS1\"\n\n# Restore the saved value for PS1\nrelease_var \"PS1\"\n</code></pre> <p>Here is an example of using these functions in a tasks.sh file</p> <pre><code>task_env() {\nif [[ $TASK_SUBCOMMAND == \"activate\" ]]\nthen\nhold_var \"PS1\"\nexport_var \"PS1\" \"(tester)\"\nelif [[ $TASK_SUBCOMMAND == \"deactivate\" ]]\nthen\nrelease_var \"PS1\"\nelif [[ $TASK_SUBCOMMAND == \"initialize\" ]]\nthen\npersit_var \"INITIALIZED\" \"true\"\nelif [[ $TASK_SUBCOMMAND == \"destroy\" ]]\nthen\nremove_var \"INITIALIZED\"\nfi\n}\n</code></pre>"},{"location":"state/#module-state","title":"Module State","text":"<p>The following module variations of the above functions do the same thing as their non-module counterparts, but they save to a globale state file.</p> <pre><code>persist_module_var \"HELLO\" \"world\"\nremove_module_var \"HELLO\"\nhold_module_var \"PS1\"\nrelease_module_var \"PS1\"\n</code></pre>"},{"location":"state/#special-state-variables","title":"Special State Variables","text":"<p>Some state variables are used to effect the outside session. These special variables are wrapped with functions that are available to tasks.</p> Function Example State Variable Action set_return_directory <code>set_return_directory \"$HOME\"</code> <code>TASK_RETURN_DIR</code> Change the current working directory for the outside bash session set_trap <code>set_trap \"echo exiting...\"</code> <code>TASK_TERM_TRAP</code> Sets an exit trap for the outside bash session clean_up_state <code>clean_up_state</code> <code>DESTROY_STATE_FILE</code> Remove the current state file after finishing task execution"},{"location":"task_files/","title":"Task Files","text":"<p>Task files are the meat and potatoes of Bash Task Master. They hold all of the important procedures for a particular context.</p> <p>By default, Bash Task Master supports the bash task syntax for task files. See the bash driver documentation for an indepth overview of the bash task syntax.</p>"},{"location":"task_files/#context-scoping","title":"Context Scoping","text":"<p>There are two main scopes that a task can run as:</p> <ul> <li>Global<ul> <li>Tasks that can be run anywhere<ul> <li>Builtin tasks</li> <li>Installed Modules</li> </ul> </li> </ul> </li> <li>Local<ul> <li>Tasks from the local task file</li> </ul> </li> </ul> <p>The first thing that Bash Task Master does is look for a task file. It starts at the current directory searches towards the root. The search ends when either a task file is found, the current home directory is searched or the search reachs the root of the filesystem (\"/\"). If a task file is found, it loads the tasks inside of it. Otherwise, only the builtin and module tasks are loaded.</p> <p>For example, take the following file structure:</p> <pre><code>/home/btm/\n\u251c\u2500\u2500 .task-master\n\u251c\u2500\u2500 notes             \u2500\u2510\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 tasks.sh       \u2502 notes scope\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 docs           \u2502\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 Linux.txt \u2500\u2518\n\u251c\u2500\u2500 project_one          \u2500\u2510\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 tasks.sh          \u2502 project_one scope\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 utils             \u2502\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 some_file.py \u2500\u2518\n\u2514\u2500\u2500 project_two            \u2510 global scope (no tasks.sh file)\n    \u2514\u2500\u2500 some_otherfile.py  \u2518\n</code></pre> <p>Running <code>task</code> in the following contexts:</p> Current directory Scope Loaded Tasks File /home/btm/notes Local /home/btm/notes/tasks.sh /home/btm/project_two Global Global /home/btm/project_one/utils Local /home/btm/project_one/tasks.sh"},{"location":"task_files/#environment-isolation","title":"Environment Isolation","text":"<p>No task that is defined in the task file is ever loaded permanently into the user's running session. The task function loads the task file in a subshell, isolating it from the current environment. Therefore, tasks can not have side effects on the current environment, other than those explicitly made by the user.</p> <p>For more on how to change the current environment refer to the state function documentation.</p> <p>Bash Task Master defines 3 functions in the user session: <code>task</code> <code>_TaskTabCompletion</code> and <code>_tmverbose_echo</code> and 1 variable <code>TASK_MASTER_HOME</code>. These are set up to be loaded in the .bashrc during installation.</p> <p>Any other additions to the user environment have to be initiated by the user.</p>"},{"location":"task_files/#task-variables","title":"Task Variables","text":"<p>Each task function is spawned inside of a subshell by the task function. This means that the child process in which tasks are being run have access to the environment variables that have been set by the task function.</p> <p>The following is a summary of the variables that are set in the task function, and are therefore available to use inside of tasks:</p> Variable Name Description Example Value TASK_COMMAND The current running command build TASK_SUBCOMMAND The current running subcommand (only applies to the bash driver) frontend TASK_DIR Directory where the task file was found. <code>$TASK_MASTER_HOME</code> in the global scope. /home/btm/notes TASK_FILE Tasks file that was loaded. /home/btm/notes/tasks.sh RUNNING_DIR The directory that task was run from /home/btm/project_one/utils DRIVER_DIR The driver directory $TASK_MASTER_HOME/lib/drivers TASK_MASTER_HOME The home directory of bash task master /home/btm/.task-master TASK_REPOS A space separated list of repo inventory files to pull modules or drivers from. Set in <code>$TASK_MASTER_HOME/config.env</code>. file:///home/btm/repo/inventory DEFAULT_EDITOR The default editor to open when modifying files. Set in <code>$TASK_MASTER_HOME/config.env</code>. vi DEFAULT_TASK_DRIVER The default task driver to use when initializing task files. Set in <code>$TASK_MASTER_HOME/config.env</code>. bash <p>For the sake of completeness, the following variables are also accessable, but should rarely be needed directly:</p> Variable Name Description Example Value LOCATION_FILE File that stores all of the stored locations. Don't mess with this file unless you are confident in fixing it. /home/btm/.task-master/state/locations.vars STATE_FILE File that stores the state for a given command /home/btm/.task-master/state/project_one/build.vars TASK_DRIVER_DICT The associative array mapping task driver names to task driver files bash=bash_driver.sh TASK_FILE_NAME_DICT The associatvie array mapping task files to task drivers tasks.sh=bash TASK_DRIVER The name of the running task driver bash TASK_FILE_DRIVER The name of the driver for the current task file bash TASK_FILE_NAME The name of the current task file tasks.sh TASKS_FILE_FOUND Denotes whether a task file was found in the current scope. (useful for modules) T DRIVER_EXECUTE_TASK Driver specific execution function bash_execute DRIVER_HELP_TASK Driver specific help function bash_help DRIVER_LIST_TASK Driver specific list function bash_list DRIVER_VALIDATE_TASK_FILE Driver function to validate task file bash_validate_file LOCAL_TASKS_REG A regex list of local tasks <code>build|run|kill</code> GLOBAL_TASKS_REG A regex list of global tasks <code>list|help|global|driver|module</code> GLOBAL_VERBOSE Set to true to log _tmverbose_echo calls to stdout 1 GLOBAL_TASK_FILE The file to load global tasks $TASK_MASTER_HOME/lib/global-tasks.sh"},{"location":"task_files/#task-variable-conventions","title":"Task Variable Conventions","text":"<p>The following conventions are followed when deciding a variable name:</p> <ul> <li>All variables available to tasks are uppercase</li> <li>Variables that reference files end in <code>_FILE</code></li> <li>Variables that reference directory end in <code>_DIR</code></li> <li>Variables that are space seperated lists end in <code>S</code></li> <li>Variables that are regexes end in <code>_REG</code></li> <li>Multi-word variables are always seperated by underscores, i.e. <code>FILE_NAME</code> vs <code>FILENAME</code></li> <li>Singular words are preferred to plural, i.e. <code>TASK_FILE</code> vs <code>TASKS_FILE</code></li> </ul>"},{"location":"task_files/#task-file-templates","title":"Task File Templates","text":"<p>Task file templates may be used when initializing a new task file. By default, the template with the same name as the driver is used. Manage templates by using the built in template command. To edit or create a template run <code>task template edit -n my_tmpl</code></p>"},{"location":"walkthrough/","title":"Walkthrough","text":""},{"location":"walkthrough/#initializing-a-task-file","title":"Initializing a Task File","text":"<p>Initializing a task file is as simple as changing to the project directory and running:</p> <pre><code>mkdir project\ncd project\ntask init\n</code></pre> <p>This will create a tasks.sh file in the current directory and bookmark the directory. The tasks.sh file is used to hold tasks that are related to the project. Bookmarking a directory saves the location so that you can quickly change directories back to the project:</p> <pre><code>cd ~\ntask goto project\n</code></pre> <p>The default name of the bookmark is the name of the directory where <code>task init</code> was called (in this case project)</p>"},{"location":"walkthrough/#creating-a-simple-task","title":"Creating a Simple Task","text":"<p>Let's say that we find ourselves running the following commands a lot:</p> <pre><code>docker run --detach --rm -it -e POSTGRES_PASSWORD=secret --name mydb postgres\ndocker stop mydb\n</code></pre> <p>We could write this into a couple tasks:</p> <pre><code>task_start() {\ndocker run --detach --rm -it -e POSTGRES_PASSWORD=secret --name mydb postgres\n}\ntask_stop() {\ndocker stop mydb\n}\n</code></pre> <p>Now to run these tasks we can run:</p> <pre><code>task start\ntask stop\n</code></pre> <p>Or we can use the <code>t</code> alias:</p> <pre><code>t start\nt stop\n</code></pre> <p>Now we have a short, contextual way of running these commands. If we ever forget what tasks are defined in the local context, we can run <code>task list</code> to list all of the local tasks.</p>"},{"location":"walkthrough/#adding-arguments","title":"Adding Arguments","text":"<p>We can easily add arguments to our newly created tasks. We just need to implement the <code>arguments_start</code> function and change <code>task_start</code> to the following:</p> <pre><code>arguments_start() {\nSTART_DESCRIPTION=\"Run the postgres database\"\nSTART_OPTIONS=\"detach:d:bool name:n:str\"\n}\n\ntask_start() {\nif [[ -z \"$ARG_NAME\" ]]\nthen\nARG_NAME=mydb\n  fi\nif [[ -n \"$ARG_DETACH\" ]]\nthen\nextra_args=--detach\n  fi\ndocker run $extra_args --rm -it -e POSTGRES_PASSWORD=secret --name $ARG_NAME postgres\n}\n</code></pre> <p>The <code>START_OPTIONS</code> variable in the arguments defines what optional arguments the task accepts. If we had instead named this variable as <code>START_REQUIREMENTS</code> these areguments would be required. Task execution does not start if a required argument is not supplied. The <code>START_DESCRIPTION</code> variable is used as a description of the task when <code>task help start</code> is called. Including a description for tasks is a good idea, as it is a simple way to document what a task is supposed to do.</p> <p>With these arguments we can run the <code>start</code> task with the following arguments:</p> <pre><code># Equivalent to: docker run --detach --rm -it -e POSTGRES_PASSWORD=secret --name mydb postgres\n$ task start --detach\n\n# Equivalent to: docker run --rm -it -e POSTGRES_PASSWORD=secret --name mydb postgres\n$ task start\n\n# Equivalent to: docker run --rm -it -e POSTGRES_PASSWORD=secret --name anotherdb postgres\n$ task start -n anotherdb\n</code></pre>"},{"location":"walkthrough/#saving-state","title":"Saving State","text":"<p>Now that we have tasks to start any number of containers, we need a way to keep track of and stop all of the containers we have started</p> <p>First we need to save the names of the containers that we started in <code>task_start</code>:</p> <pre><code>task_start() {\nif [[ -z \"$ARG_NAME\" ]]\nthen\nARG_NAME=mydb\n  fi\nif [[ -n \"$ARG_DETACH\" ]]\nthen\nextra_args=-d\n    persist_var \"STARTED\" \"$STARTED $ARG_NAME\"\nfi\ndocker run $extra_args --rm -it -e POSTGRES_PASSWORD=secret --name $ARG_NAME postgres\n}\n</code></pre> <p>Then we can add another task to show what containers we have started:</p> <pre><code>task_show() {\necho Started containers: $STARTED\n}\n</code></pre> <p>Finally we can update the stop task to stop all of the containers:</p> <pre><code>task_stop() {\ndocker stop $STARTED\nremove_var \"STARTED\"\n}\n</code></pre> <p>Now to test we can run the following:</p> <pre><code># Start a few containers\n$ t start -d\nRunning start: task...\nc164e181e...\n$ t start -d -n other\nRunning start: task...\n34ef64e18...\n$ t start -d -n another\nRunning start: task...\n164ae18fc...\n\n# Show the running containers\n$ t show\nmydb other another\n\n# Stop all of the running containers\n$ t stop\n</code></pre>"},{"location":"walkthrough/#make-it-portable","title":"Make it portable","text":"<p>Now that we have our task written, suppose we want to make it available to other projects in our local environment. There are two ways to accomplish this: modules or templates</p>"},{"location":"walkthrough/#making-a-template","title":"Making a template","text":"<p>Templates are useful for when you have a basic task file that you like to tweak for each of your projects. All we need to do is create a template file in <code>$TASK_MASTER_HOME/templates</code> and then use that template as an argument to <code>task init</code>.</p> <p>For our example lets copy our tasks.sh file to a file named pgdocker.template:</p> <pre><code>cp tasks.sh $TASK_MASTER_HOME/templates/pgdocker.template\n</code></pre> <p>Then to use it as a template we just need to specify <code>--template pgdocker</code> (<code>-t</code> for short) when calling <code>task init</code>:</p> <pre><code>cd\nmkdir new_project\ncd new_project\ntask init -t pgdocker\n</code></pre> <p>The created tasks.sh file is a direct copy of the pgdocker.template file.  We can list our tasks and our templates:</p> <pre><code>$ task list\nRunning list: task...\nstart         show      stop\n\n$ task template list\nRunning template:list task...\npgdocker\n</code></pre>"},{"location":"walkthrough/#making-a-module","title":"Making a module","text":"<p>Modules are useful for when you want to make a task available to all projects in the global scope. Modules are stored in the <code>$TASK_MASTER_HOME/modules</code> directory and they must end in <code>-module.sh</code>. Any task defined in a module must be marked as readonly to show up in the global scope. This prevents local tasks from overwriting module functions. As a general rule, there should only be a single task per module.</p> <p>In the case of converting our task file to a module, we'll have to do some editing to put all of our tasks together. In <code>$TASK_MASTER_HOME/modules/pgdocker-module.sh</code> we can write:</p> <pre><code>arguments_pgdocker() {\nPGDOCKER_DESCRIPTION=\"Manage postgres containers\"\nSUBCOMMANDS=\"start|show|stop\"\n\nSTART_DESCRIPTION=\"Start a postgres container\"\nSTART_OPTIONS=\"name:n:str detach:d:bool\"\n\nSHOW_DESCRIPTION=\"Show the running postgres containers\"\n\nSTOP_DESCRIPTION=\"Stop all the running postgres containers\"\n}\n\ntask_pgdocker() {\nif [[ \"$TASK_SUBCOMMAND\" == \"start\" ]]\nthen\nif [[ -z \"$ARG_NAME\" ]]\nthen\nARG_NAME=mydb\n    fi\nif [[ -n \"$ARG_DETACH\" ]]\nthen\nextra_args=-d\n      # Notice the change here to persist_module_var\npersist_module_var \"STARTED\" \"$STARTED $ARG_NAME\"\nfi\ndocker run $extra_args --rm -it -e POSTGRES_PASSWORD=secret --name $ARG_NAME postgres\n\n  elif [[ \"$TASK_SUBCOMMAND\" == \"show\" ]]\nthen\necho Started containers: $STARTED\n\nelif [[ \"$TASK_SUBCOMMAND\" == \"stop\" ]]\nthen\ndocker stop $STARTED\n# Notic the change here to remove_module_var\nremove_module_var \"STARTED\"\nfi\n}\n\n# Tasks in modules are required to be marked as readonly\nreadonly -f task_pgdocker\n</code></pre> <p>Note</p> <p>We are using <code>persist_module_var</code> and <code>remove_module_var</code> here instead of <code>persist_var</code> and <code>remove_var</code>. The module variations of these function provide a mechanism to save module variables independently of task file context. If we were to use <code>persist_var</code>, state would depend on the current working directory.</p> <p>Now the task will show when we list the global task:</p> <pre><code>$ task list -g\nRunning list: task...\n... pgdocker ...\n\n$ task help pgdocker\nRunning help:pgdocker task...\nCommand: task pgdocker\n  Manage postgres containers\n\nCommand: task pgdocker start\n  Start a postgres container\n  Optional:\n    --name, -n str\n    --detach, -d\n\nCommand: task pgdocker show\n  Show the running postgres containers\n\nCommand: task pgdocker stop\n  Stop all the running postgres containers\n</code></pre>"}]}